<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hong Kong Bat Acoustic Project</title>

  <!-- Leafletæ ¸å¿ƒ -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-gesture-handling/dist/leaflet-gesture-handling.min.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-gesture-handling"></script>
  
  <!-- åŠ å…¥ Lucide çš„ CDN -->
  <script src="https://unpkg.com/lucide@latest"></script>
  
  <!-- Responsive Map Size -->
  <style>
    #map {
      width: 1140px;
      height: 800px;
    }

    @media (max-width: 1023px) {
      #map {
        height: 80vh;
        width: 100%;
      }
    }
    
    .floatingTooltip {
      position: absolute;
      background: rgba(255,255,255,0.95);
      color: #000;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 13px;
      font-family: Arial, sans-serif; 
      line-height: 1.4;
      pointer-events: auto;
      z-index: 1000;
      max-width: 320px;
      word-break: break-word;
      overflow: visible;
    }

    .tooltip-close-button:hover {
      background: #333;
    }

    .tooltip-content {
      padding-top: 0px;
    }

    .tooltip-container {
      position: relative;
    }

    /* æ”¹ç‚ºçµ•å°å®šä½ + åœ“å½¢é¢¨æ ¼ */
    a.tooltip-close {
      position: absolute;
      top: -18px;
      right: -23px;
      display: inline-block;
      width: 26px;
      height: 26px;
      line-height: 26px;
      text-align: center;
      border-radius: 50%;
      font-size: 16px;
      font-weight: bold;
      color: #333 !important;
      background: #eee;
      text-decoration: none !important;
      -webkit-appearance: none !important;
      appearance: none !important;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      z-index: 10;
    }

    a.tooltip-close:hover {
      background: #ccc !important;
    }


    /* ğŸ”µ CRS + Scale å…±ç”¨å®¹å™¨æ¨£å¼ */
    #coord-scale-wrapper {
      position: absolute;
      bottom: 5px;
      left: 5px;
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(240, 248, 255, 0.95); /* æ·ºè—åŠé€æ˜èƒŒæ™¯ */
      border: 1px solid #bbb;
      padding: 4px 10px;
      border-radius: 4px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      color: #111;
      z-index: 1001;
    }
    
    .crs-selector select {
      margin-right: 4px;
      font-weight: bold;
      color: #0000cc;
      border: none;
      background: transparent;
      text-decoration: underline;
      cursor: pointer;
    }
    
    .crs-selector span {
      font-weight: bold;
      color: #222;
    }
    
    /* è®“ Leaflet scale æ§åˆ¶ä¸å¹²æ“¾å®šä½ */
    .leaflet-control-scale {
      position: static !important;
      margin-left: 8px;
    }
    
    /*  çµ±ä¸€ input è¼¸å…¥æ¡†æ¨£å¼ */
     #gotoPanel input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
    }
    /*   èª¿æ•´ radio çš„å¤–è§€é å·¦ + å°é½Š */
      #gotoPanel label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-weight: normal;
    } 
    .goto-row {
      display: grid;
      grid-template-columns: 20px 80px 120px;
      align-items: center;
      gap: 8px;
    }
    
    #clearBtn {
      background: #f8bfc4;
    }
    
    #clearBtn:hover {
      background-color: #d9534f;
      color: white;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
    }
    
    #goBtn {
      background: #3d7728;
      color: white;
    }
    
    #goBtn:hover {
      background-color: #1e4f1b;
      color: white;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      cursor: pointer;
    }
    
    .info.legend {
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      font: 13px Arial, sans-serif;
      color: #333;
      line-height: 1.4;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      border: 1px solid #ccc;
    }

    /* Tool Bar Button Style*/
     .single-btn {
      position: absolute;
      width: 30px;
      height: 30px;
      line-height: 26px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      cursor: pointer;
    }
    
    .single-btn:hover {
      background: #f4f4f4;
    }

    #drawPointBtn.active {
      background: #eee;
      box-shadow: inset 0 0 0 1px #666;
      border-color: #666;
    } 
    
    #locateBtn.active {
      background: #eee;
      box-shadow: inset 0 0 0 2px #666;
      border-color: #666;
    }  
    
    .lucide-locate-icon i svg {
      fill: #007aff;
      stroke: #007aff;
      stroke-width: 1.5px;
    }
    
    .rotatable-icon {
      transition: transform 0.2s ease-out;
    }
  </style>
</head>
<body>

  <div id="map" style="position: relative;">
    <div id="coord-scale-wrapper">
      <div class="crs-selector">
        <select id="crsMode">
          <option value="hk1980">HK1980</option>
          <option value="wgs84">WGS84</option>
        </select>
        <span id="mouseCoords">X: â€“, Y: â€“</span>
      </div>
    </div>
  <a id="homeBtn" class="leaflet-control leaflet-bar single-btn" href="#" title="Go Home"
     style="top: 95px; left: 10px;">
    <i data-lucide="home" style="width: 14px; height: 14px; color: black;"></i>
  </a>
  <a id="gotoToggleBtn" class="leaflet-control leaflet-bar single-btn" href="#" title="Go To Point"
     style="top: 130px; left: 10px;">
    <i data-lucide="crosshair" style="width: 14px; height: 14px; color: black;"></i>
  </a>
  <a id="drawPointBtn" class="leaflet-control leaflet-bar single-btn" href="#" title="Draw Point"
     style="top: 165px; left: 10px;">
    <i data-lucide="map-pin" style="width: 14px; height: 14px; color: black;"></i>
  </a>
  <a id="locateBtn" class="leaflet-control leaflet-bar single-btn" href="#" title="å®šä½è¿½è¹¤"
     style="top: 200px; left: 10px;">
    <i data-lucide="navigation" style="width: 14px; height: 14px; color: black;"></i>
  </a>
  </div>

  <!-- Go To Point åŠŸèƒ½ -->
    <div id="gotoPanel" style="
    display: none;
    position: absolute;
    top: 124px; left: 56px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 15px 15px;
    font-family: 'Arial', sans-serif;
    font-size: 14px;
    width: 250px;
    z-index: 1100;
    ">

    <h4 style="margin-top: 0;">Go To Point</h4>
    
    <div class="goto-row">
      <input type="radio" name="coordMode" value="hk1980" id="modeHK" />
      <label for="modeHK">Easting (X):</label>
      <input id="inputX" type="number" placeholder="828988" />
    </div>
    
    <div class="goto-row">
      <span></span>
      <label>Northing (Y):</label>
      <input id="inputY" type="number" placeholder="824199" />
    </div>
    
        
    <div class="goto-row">
      <input type="radio" name="coordMode" value="wgs84" id="modeWGS" />
      <label for="modeWGS">Latitude:</label>
      <input id="inputLat" type="number" placeholder="22.356" />
    </div>
    
    <div class="goto-row">
      <span></span>
      <label>Longitude:</label>
      <input id="inputLng" type="number" placeholder="114.101" />
    </div>

    <button id="clearBtn"
      style="border: none; padding: 6px 12px; border-radius: 6px; margin-right: 8px;">
      Clear All Point
    </button>
    
    <button id="goBtn"
      style="color: white; border: none; padding: 6px 20px; border-radius: 6px;">
      Go
    </button>

  </div>

  <!-- Hover Tooltip -->
  <div id="hoverTooltip" style="
    display: none;
    position: absolute;
    background: rgba(255,255,255,0.95);
    color: #000;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    font-family: Arial, sans-serif;
    line-height: 1.4;
    pointer-events: none;
    z-index: 999;
  "></div>

  <p id="last-modified" style="text-align:center; font-size:12px; color:gray; margin-top:30px;"></p>

  <!-- Proj4 è½‰æ›å·¥å…· -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>

  <script>
    const map = L.map('map', {
      gestureHandling: true,
    });
    
    const hongKongBounds = [
      [22.1500, 113.8250],
      [22.5500, 114.4000]
    ];
    map.fitBounds(hongKongBounds);

    const scaleControl = L.control.scale({ imperial: false });
    scaleControl.addTo(map);

    // å®šç¾©æ­£ç¢ºçš„ HK1980 èˆ‡ WGS84 è½‰æ›åƒæ•¸
    proj4.defs("EPSG:2326", "+proj=tmerc +lat_0=22.31213333333334 +lon_0=114.1785555555556 +k=1 +x_0=836694.05 +y_0=819069.8 +ellps=intl +towgs84=-162.619,-276.959,-161.764,0.067753,-2.24365,-1.15883,-1.09425 +units=m +no_defs");
    
    // ç­‰å¾… Leaflet è¼‰å…¥å¾Œå°‡æ¯”ä¾‹å°º DOM æ’å…¥ wrapper
    map.whenReady(() => {
      const scaleEl = document.querySelector('.leaflet-control-scale');
      const wrapper = document.getElementById('coord-scale-wrapper');
      if (scaleEl && wrapper) {
        wrapper.appendChild(scaleEl);
      }
      lucide.createIcons();  // åˆå§‹åŒ– Lucide Icons
    });

    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(map);
    const esriSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles Â© Esri' });
    const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {attribution: 'CARTO'});
    const googleStreets = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', { attribution: 'Map data Â©2024 Google' });
    const googleSatellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: 'Imagery Â©2024 Google' });
    const googleHybrid = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', { attribution: 'Imagery Â©2024 Google' });
    const baseMaps = {
      "è¡—é“åœ– (OSM)": streets,
      "è¡›æ˜Ÿåœ– (Esri)": esriSatellite,
      "è¡—é“åœ– (Carto)": cartoLight,
      "Google è¡—é“åœ–": googleStreets,
      "Google è¡›æ˜Ÿåœ–": googleSatellite,
      "Google æ··åˆåœ–": googleHybrid
    };
    const isSmallDevice = window.matchMedia('(max-width: 1023px)').matches;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const layersControl = L.control.layers(baseMaps, {}, { collapsed: true }).addTo(map);
    const gotoMarkers = [];  // å„²å­˜ Go To Point å»ºç«‹çš„ marker
    
    // Home Button //
    document.getElementById('homeBtn').addEventListener('click', () => {
      map.fitBounds(hongKongBounds);
    });
    
    const legend = L.control({ position: 'bottomright' });  // All Bat Gridçš„Legend
    legend.onAdd = function () {
      const div = L.DomUtil.create('div', 'info legend');
      const grades = [1, 6, 11, 16, 21];
      const labels = [];
      const colors = ["#fde0dd", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"];
    
      div.innerHTML = '<strong>No. of Species</strong><br>';
    
      for (let i = 0; i < grades.length; i++) {
        const from = grades[i];
        const to = grades[i + 1] - 1;
        const rangeLabel = to ? `${from}â€“${to}` : `> ${from - 1}`;
        div.innerHTML += `
          <i style="background:${colors[i]}; width: 14px; height: 14px; display: inline-block; margin-right: 6px; border-radius: 2px;"></i>
          ${rangeLabel}<br>
        `;
      }
      return div;
    };

     map.on('overlayadd', function (e) {
      if (e.name === "All Bat Distribution (Grid)") {
        legend.addTo(map);
      }
    });
    
    map.on('overlayremove', function (e) {
      if (e.name === "All Bat Distribution (Grid)") {
        map.removeControl(legend);
      }
    });
    
    let gridLayer = L.geoJSON(null, { style: { color: '#666', weight: 1, fillColor: '#41b6c4', fillOpacity: 0.3 } });
    let lockedLayers = [];
    let tooltipElements = [];
    let manualMoved = [];
    let maxLockedTooltips = 3;

    function positionTooltipToSameOffset(domElement, latlng) {
      const point = map.latLngToContainerPoint(latlng);
      const mapRect = map.getContainer().getBoundingClientRect();
      const left = mapRect.left + point.x + 15;
      const top = mapRect.top + point.y + 15;

      domElement.style.position = 'absolute';
      domElement.style.left = `${left}px`;
      domElement.style.top = `${top}px`;
    }

      function adjustTooltipPosition(tooltip, point) {
        if (getComputedStyle(tooltip).position !== 'absolute') {
          tooltip.style.position = 'absolute';
        }
      
        const mapSize = map.getSize();
        let left = point.x + 15;
        let top = point.y + 15;
      
        if (left + tooltip.offsetWidth > mapSize.x) left = point.x - tooltip.offsetWidth - 15;
        if (top + tooltip.offsetHeight > mapSize.y) top = point.y - tooltip.offsetHeight - 15;
        if (left < 0) left = 10;
        if (top < 0) top = 10;
      
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
      }

    function updateAllLockedTooltips() {
      lockedLayers.forEach((layer, index) => {
        if (manualMoved[index]) return;
        const tooltip = tooltipElements[index];
        const center = map.latLngToContainerPoint(layer.getBounds().getCenter());
        adjustTooltipPosition(tooltip, center);
      });
    }

    function makeTooltipDraggable(tooltip, index) {
      let isDragging = false;
      let offsetX, offsetY;

      tooltip.addEventListener('mousedown', function(e) {
        isDragging = true;
        offsetX = e.clientX - tooltip.offsetLeft;
        offsetY = e.clientY - tooltip.offsetTop;
        tooltip.style.cursor = 'move';
        tooltip.style.opacity = '0.7';
        e.stopPropagation();
      });

      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          tooltip.style.left = (e.clientX - offsetX) + 'px';
          tooltip.style.top = (e.clientY - offsetY) + 'px';
        }
      });

      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          tooltip.style.cursor = 'default';
          tooltip.style.transition = 'opacity 0.2s ease';
          tooltip.style.opacity = '1';
          manualMoved[index] = true;
          setTimeout(() => { tooltip.style.transition = ''; }, 200);
        }
      });
    }

    function openLockTooltip(layer) {
      const tooltip = document.createElement('div');
      tooltip.className = 'floatingTooltip';
      tooltip.setAttribute('data-layer-id', L.stamp(layer));
      tooltip.innerHTML = `
        <div class="tooltip-container">
          <a href="#" class="tooltip-close" onclick="closeLockTooltip(event, this);">âœ–</a>
          <div class="tooltip-content">
            ${layer.options.tooltipContent}
          </div>
        </div>
      `;
      document.getElementById('map').appendChild(tooltip);

      lockedLayers.push(layer);
      tooltipElements.push(tooltip);
      manualMoved.push(false);

      const centerPoint = map.latLngToContainerPoint(layer.getBounds().getCenter());
      setTimeout(() => {
        adjustTooltipPosition(tooltip, centerPoint);}, 30); 
     
      makeTooltipDraggable(tooltip, lockedLayers.length - 1);
    }

    function closeLockTooltip(event, closeButton) {
      event.preventDefault();
      const tooltip = closeButton.closest('.floatingTooltip');
      const layerId = parseInt(tooltip.dataset.layerId);
      const idx = lockedLayers.findIndex(l => L.stamp(l) === layerId);

      if (idx !== -1) {
        const layer = lockedLayers[idx];
      const gridNo = layer.feature.properties.Grid_No;
      const count = speciesData[gridNo] ? speciesData[gridNo].count : 0;
      layer.setStyle(getGridStyle(count));
        lockedLayers.splice(idx, 1);
        tooltipElements[idx].remove();
        tooltipElements.splice(idx, 1);
        manualMoved.splice(idx, 1);
      }
    }

    const hoverTooltip = document.getElementById('hoverTooltip');
    
    function getGridStyle(count) {
      let fillColor = "#fff";
      let fillOpacity = 0;
    
      if (count === 0 || count === "0" || count === "" || count === null) {
        fillOpacity = 0;
      } else {
        count = Number(count);
        fillOpacity = 0.75;
      if (count >= 1 && count <= 5) fillColor = "#fde0dd";    // very light pink
      else if (count <= 10)          fillColor = "#fbb4b9";    // light pink
      else if (count <= 15)          fillColor = "#f768a1";    // medium pink-red
      else if (count <= 20)          fillColor = "#c51b8a";    // strong magenta-red
      else                           fillColor = "#7a0177";    // dark purple-red
      }
    
      return {
        color: "#666",
        weight: 1,
        fillColor,
        fillOpacity
      };
    }
    
    function setupGridLayerFeature(feature, layer) {
      const gridNo = feature.properties.Grid_No;
      if (speciesData[gridNo]) {
        const info = speciesData[gridNo];
        let content = "";

        if (!info.list || info.list.trim() === "" || info.list === "N/A") {
          content = `<strong>ç·¨è™Ÿ:</strong> ${gridNo}<br>æš«ç„¡ç‰©ç¨®è¨˜éŒ„`;
        } else {
          const speciesArray = info.list.split(', ').sort();
          const speciesListHtml = speciesArray.map((s, i) => `${i + 1}. <i>${s}</i>`).join('<br>');
          content = `<strong>ç·¨è™Ÿ:</strong> ${gridNo}<br><strong>æ•¸é‡:</strong> ${info.count} ç¨®<br><strong>æ¸…å–®:</strong><br>${speciesListHtml}`;
        }

        layer.options.tooltipContent = content;

        if (!isTouchDevice) {
          layer.on('mouseover', function() {
            if (!lockedLayers.includes(this)) {
              hoverTooltip.innerHTML = this.options.tooltipContent;
              hoverTooltip.style.display = 'block';
            }
          });

          layer.on('mousemove', function(e) {
            if (!lockedLayers.includes(this)) {
              const point = map.latLngToContainerPoint(e.latlng);
              adjustTooltipPosition(hoverTooltip, point);
            }
          });

          layer.on('mouseout', function() {
            hoverTooltip.style.display = 'none';
          });
        }

        layer.on('click', function() {
          if (lockedLayers.includes(this)) {
            const idx = lockedLayers.indexOf(this);
            lockedLayers.splice(idx, 1);
            tooltipElements[idx].remove();
            tooltipElements.splice(idx, 1);
            manualMoved.splice(idx, 1);
            this.setStyle(getGridStyle(info.count));
          } else {
            if (lockedLayers.length >= maxLockedTooltips) {
              alert('æœ€å¤šåªèƒ½é–å®š ' + maxLockedTooltips + ' å€‹Tooltip');
              return;
            }
            this.setStyle({ color: '#333', weight: 2, fillColor: '#ffcc00', fillOpacity: 0.7 });
            openLockTooltip(this);
          }
        });
      }
    }

    map.on('move zoom', () => {
      updateAllLockedTooltips();
    });

    let speciesData = {};

    fetch('https://opensheet.elk.sh/1Al_sWwiIU6DtQv6sMFvXb9wBUbBiE-zcYk8vEwV82x8/sheet1')
      .then(r => r.json())
      .then(data => {
        data.forEach(item => {
          speciesData[item["Grid No."]] = {
            list: item["Species List"],
            count: item["No. of Species"]
          };
        });
        fetch('https://raw.githubusercontent.com/PanTong55/hkgrid/main/hkgrid.geojson')
          .then(r => r.json())
          .then(gridData => {
            gridLayer.options.onEachFeature = setupGridLayerFeature;
            gridLayer = L.geoJSON(gridData, {
              style: function(feature) {
                const gridNo = feature.properties.Grid_No;
                const info = speciesData[gridNo];
                const count = info ? info.count : 0;
                return getGridStyle(count);
              },
              onEachFeature: setupGridLayerFeature
            });
            layersControl.addOverlay(gridLayer, "All Bat Distribution (Grid)");
          });
      });

    const crsModeSelect = document.getElementById('crsMode');
    const coordDisplay = document.getElementById('mouseCoords');

    map.on('mousemove', function (e) {
      const mode = crsModeSelect.value;
      if (mode === 'wgs84') {
        coordDisplay.textContent = `Lon: ${e.latlng.lng.toFixed(6)}  Lat: ${e.latlng.lat.toFixed(6)}`;
      } else {
        const [x, y] = proj4("EPSG:4326", "EPSG:2326", [e.latlng.lng, e.latlng.lat]);
        coordDisplay.textContent = `X: ${Math.round(x)}  Y: ${Math.round(y)}`;
      }
    });
    
    // åŠ  Go To Point
    document.getElementById('gotoToggleBtn').addEventListener('click', () => {
      const panel = document.getElementById('gotoPanel');
      const btn = document.getElementById('gotoToggleBtn');
      
      const isOpen = panel.style.display === 'block';
      
      if (isOpen) {
        panel.style.display = 'none';
        btn.innerHTML = '<i data-lucide="crosshair" style="width: 14px; height: 14px; color: black;"></i>';
        lucide.createIcons(); // â† é¡¯ç¤ºåœ–ç¤º
      } else {
        panel.style.display = 'block';
        btn.innerHTML = '<i data-lucide="chevrons-left" style="width: 14px; height: 14px; color: black;"></i>';
        lucide.createIcons(); // â† é¡¯ç¤ºè¿”å›ç®­é ­
      }
    });

    document.getElementById('goBtn').addEventListener('click', () => {
      const mode = document.querySelector('input[name="coordMode"]:checked').value;
    
      let latlng = null;
    
      if (mode === 'hk1980') {
        const x = parseFloat(document.getElementById('inputX').value);
        const y = parseFloat(document.getElementById('inputY').value);
        if (!isNaN(x) && !isNaN(y)) {
        const result = proj4("EPSG:2326", "EPSG:4326", [x, y]);
        latlng = { lat: result[1], lng: result[0] };
        }
      } else {
        const lat = parseFloat(document.getElementById('inputLat').value);
        const lng = parseFloat(document.getElementById('inputLng').value);
        if (!isNaN(lat) && !isNaN(lng)) {
          latlng = { lat, lng };
        }
      }
    
    if (latlng) {
      map.setView(latlng, 16);
      const marker = L.marker(latlng).addTo(map);
      gotoMarkers.push(marker); // âœ… åŠ å…¥ marker é™£åˆ—ä¸­
    }
    });
    
    document.getElementById('clearBtn').addEventListener('click', () => {
      gotoMarkers.forEach(m => map.removeLayer(m)); // âœ… å¾åœ°åœ–ç§»é™¤æ‰€æœ‰ marker
      gotoMarkers.length = 0; // âœ… æ¸…ç©ºé™£åˆ—
    });

    // åŠ ç•«é»åŠŸèƒ½è®Šæ•¸èˆ‡åˆå§‹åŒ–
    let drawMode = false;
    let drawnPoints = [];
    
    const drawPointBtn = document.getElementById('drawPointBtn');
    
    // ç•«é»æŒ‰éˆ•åˆ‡æ›
    drawPointBtn.addEventListener('click', () => {
      drawMode = !drawMode;
    
      drawPointBtn.classList.toggle('active', drawMode);
    });
    
    let drawnTooltips = {};
    
    function createPointTooltip(marker, content) {
      const tooltip = document.createElement('div');
      tooltip.className = 'floatingTooltip';
      tooltip.innerHTML = `
        <div class="tooltip-container">
          <a href="#" class="tooltip-close" onclick="deleteDrawnMarker(event, ${L.stamp(marker)});">âœ–</a>
          <div class="tooltip-content">${content}</div>
        </div>
      `;
      document.getElementById('map').appendChild(tooltip);
      return tooltip;
    }
    
    function updateAllDrawnTooltips() {
      drawnPoints.forEach((marker) => {
        const tooltip = drawnTooltips[L.stamp(marker)];
        if (!tooltip) return;
        const point = map.latLngToContainerPoint(marker.getLatLng());
        let left = point.x + 5;
        let top = point.y + 5;
        const mapSize = map.getSize();
        if (left + tooltip.offsetWidth > mapSize.x) left = point.x - tooltip.offsetWidth - 15;
        if (top + tooltip.offsetHeight > mapSize.y) top = point.y - tooltip.offsetHeight - 15;
        if (left < 0) left = 10;
        if (top < 0) top = 10;
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      });
    }
    
    window.deleteDrawnMarker = function (event, markerId) {
      event.preventDefault();
      const idx = drawnPoints.findIndex(m => L.stamp(m) === markerId);
      if (idx !== -1) {
        map.removeLayer(drawnPoints[idx]);
        if (drawnTooltips[markerId]) drawnTooltips[markerId].remove();
        drawnPoints.splice(idx, 1);
        delete drawnTooltips[markerId];
      }
    };
    
    map.on('move zoom', updateAllDrawnTooltips);
    
    // âœ… é»åœ°åœ–å»ºç«‹ Markerï¼ˆç•«é»æ¨¡å¼å•Ÿå‹•æ™‚ï¼‰
    map.on('click', function (e) {
      // ğŸ›¡ é¿å…èª¤é» UI æ§ä»¶æˆ–æŒ‰éˆ•
      const el = e.originalEvent.target;
      if (
        ['a', 'button', 'input', 'label', 'select', 'i', 'svg', 'path'].includes(el.tagName.toLowerCase()) ||
        el.closest('.leaflet-control')
      ) return;
    
      if (!drawMode) return;
    
      const latlng = e.latlng;
      const mode = crsModeSelect.value;
      let popupContent = '';
    
      if (mode === 'wgs84') {
        popupContent = `Lon: ${latlng.lng.toFixed(6)}<br>Lat: ${latlng.lat.toFixed(6)}`;
      } else {
        const [x, y] = proj4("EPSG:4326", "EPSG:2326", [latlng.lng, latlng.lat]);
        popupContent = `X: ${Math.round(x)}<br>Y: ${Math.round(y)}`;
      }
    
      const marker = L.marker(latlng).addTo(map);
      drawnPoints.push(marker);
    
      marker.on('click', function () {
        const markerId = L.stamp(marker);
        if (drawnTooltips[markerId]) {
          drawnTooltips[markerId].remove();
          delete drawnTooltips[markerId];
        } else {
          const tooltip = createPointTooltip(marker, popupContent);
          drawnTooltips[markerId] = tooltip;
          updateAllDrawnTooltips();
        }
      });
    });
    
    // å¯¦æ™‚å®šä½
    let currentRadius = 0;

    function animateAccuracyCircle(targetRadius) {
      const duration = 400; // å‹•ç•«é•·åº¦ï¼Œæ¯«ç§’
      const start = performance.now();
      const initial = currentRadius;

      function step(ts) {
        const progress = Math.min((ts - start) / duration, 1);
        const eased = initial + (targetRadius - initial) * easeOutCubic(progress);
        accuracyCircle.setRadius(eased);

        if (progress < 1) {
          requestAnimationFrame(step);
        } else {
          currentRadius = targetRadius;
        }
      }
      requestAnimationFrame(step);
    }

    function easeOutCubic(t) {
      return (--t) * t * t + 1;
    }

    function animateMarkerTo(marker, newLatLng, duration = 400) {
      const startLatLng = marker.getLatLng();
      const startTime = performance.now();

      function step(timestamp) {
        const elapsed = timestamp - startTime;
        const t = Math.min(elapsed / duration, 1); // 0 ~ 1
        const eased = easeOutCubic(t);
        const lat = startLatLng.lat + (newLatLng.lat - startLatLng.lat) * eased;
        const lng = startLatLng.lng + (newLatLng.lng - startLatLng.lng) * eased;

        marker.setLatLng([lat, lng]);

        if (t < 1) {
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    }


function rotateMarker(marker, angle) {
  if (!marker) return;
  const el = marker.getElement();
  if (el) {
    const rotateContainer = el.querySelector('.rotate-container');
    if (rotateContainer) {
      rotateContainer.style.transform = `rotate(${angle}deg)`;
      rotateContainer.style.transformOrigin = 'center';
    }
  }
}

const handleHeading = (e) => {
  if (e.alpha != null) {
    const heading = 360 - e.alpha;
    window.latestHeading = heading;
    rotateMarker(locateMarker, heading);

    if (locateMarker && !locateMarker._hasInitialRotation) {
      rotateMarker(locateMarker, heading);
      locateMarker._hasInitialRotation = true;
    }
  }
};

function updateAlphaStatus(alphaValue) {
  const alphaDisplay = document.getElementById('alpha-status');
  if (!alphaDisplay) return;

  const displayText = (alphaValue != null)
    ? `Î±: ${alphaValue.toFixed(2)}Â°`
    : 'Î±: null';

  alphaDisplay.textContent = displayText;
}

    
    let locateMarker = null;
    let accuracyCircle = null;
    let watchId = null;
    let autoFollow = true;
    
    const locateBtn = document.getElementById('locateBtn');
    
    locateBtn.addEventListener('click', () => {
     if (watchId !== null) {
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
      if (locateMarker) {
        map.removeLayer(locateMarker);
        locateMarker = null;
      }
      if (accuracyCircle) {
        map.removeLayer(accuracyCircle);
        accuracyCircle = null;
      }
      locateBtn.classList.remove('active');
      window.removeEventListener('deviceorientation', handleHeading);
      return;
    }

      locateBtn.classList.add('active');
      autoFollow = true;

       if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(response => {
          if (response === 'granted') {
            window.addEventListener('deviceorientation', handleHeading, true);
            headingListenerAdded = true;
          }
        });
      } else {
        window.addEventListener('deviceorientation', handleHeading, true);
        headingListenerAdded = true;
      }     
    
      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const latlng = [pos.coords.latitude, pos.coords.longitude];
          const accuracy = pos.coords.accuracy;
    
          if (!locateMarker) {
            locateMarker = L.marker(latlng, {
              icon: L.divIcon({
                className: 'lucide-locate-icon',
                html: `
                  <div class="rotate-container">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="#007aff" viewBox="0 0 24 24">
                      <path d="M12 2l6 20-6-4-6 4 6-20z"/>
                    </svg>
                  </div>
                `,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
              })
            }).addTo(map);

            lucide.createIcons();
          } else {
            animateMarkerTo(locateMarker, L.latLng(latlng));
          }
    
          if (!accuracyCircle) {
            accuracyCircle = L.circle(latlng, {
              radius: accuracy,
              color: '#1E90FF',
              weight: 2,
              fillColor: '#1E90FF',
              fillOpacity: 0.15
            }).addTo(map);
  			currentRadius = accuracy; // âœ… åˆå§‹åŒ– currentRadius
          } else {
            accuracyCircle.setLatLng(latlng);              // âœ… ä¿æŒåœ“åœˆèˆ‡ marker ä¸­å¿ƒä¸€è‡´
            animateAccuracyCircle(accuracy);               // âœ… å¹³æ»‘éæ¸¡æ–°åŠå¾‘
          }
    
          const bounds = map.getBounds();
    
          if (autoFollow) {
            map.setView(latlng, 17);
          } else {
            const margin = bounds.pad(-0.15); // é‚Šç•Œ 15% å…§æ‰ç®—å®‰å…¨
            if (!margin.contains(latlng)) {
              autoFollow = true;
              map.setView(latlng);
            }
          }
        },
        (err) => {
          alert('å®šä½å¤±æ•—ï¼š' + err.message);
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 0
        }
      );
    });

    // é¡¯ç¤ºæ­¤é æœ€å¾Œä¿®æ”¹æ™‚é–“
    const lastModified = new Date(document.lastModified);
    const formatted = lastModified.toLocaleString('zh-Hant', {
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    });
    document.getElementById("last-modified").textContent = "æ­¤é æœ€å¾Œä¿®æ”¹æ™‚é–“ï¼š" + formatted;
  </script>
  
</body>
</html>
