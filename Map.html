<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hong Kong Bat Acoustic Project</title>

  <!-- Leafletæ ¸å¿ƒ -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-gesture-handling/dist/leaflet-gesture-handling.min.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-gesture-handling"></script>
  
  <!-- åŠ å…¥ Lucide çš„ CDN -->
  <script src="https://unpkg.com/lucide@latest"></script>
  
  <!-- Responsive Map Size -->
  <style>
    #map {
      width: 1140px;
      height: 700px;
    }

    @media (max-width: 1023px) {
      #map {
        height: 75vh;
        width: 100%;
      }
    }
    
    .floatingTooltip {
      position: absolute;
      background: rgba(255,255,255,0.95);
      color: #000;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 6px 10px; /* ä¸Šæ–¹å¤šç•™ç©ºé–“ */
      font-size: 13px;
      font-family: Arial, sans-serif; 
      line-height: 1.4;
      pointer-events: auto;
      z-index: 1000;
      max-width: 320px;
      word-break: break-word;
      overflow: visible; /* å…è¨±å­å…ƒç´ (XæŒ‰éˆ•)å‡¸å‡º */
    }

    .tooltip-close-button:hover {
      background: #333;
    }

    .tooltip-content {
      padding-top: 0px; /* ä¸éœ€è¦ç‰¹åˆ¥ç•™ç©ºé–“ï¼Œå› ç‚º Xå·²ç¶“æ˜¯å‡¸å‡ºå¤–é¢ */
    }

    /* çµ±ä¸€ Tooltip å®¹å™¨è®“å®ƒå¯ä»¥è£ã€Œæµ®å‡ºçš„ Xã€ */
    .tooltip-container {
      position: relative;
    }

    /* æ”¹ç‚ºçµ•å°å®šä½ + åœ“å½¢é¢¨æ ¼ */
    a.tooltip-close {
      position: absolute;
      top: -18px;
      right: -23px;
      display: inline-block;
      width: 26px;
      height: 26px;
      line-height: 26px;
      text-align: center;
      border-radius: 50%;
      font-size: 16px;
      font-weight: bold;
      color: #333 !important;
      background: #eee;
      text-decoration: none !important;
      -webkit-appearance: none !important;
      appearance: none !important;
      box-shadow: 0 0 2px rgba(0, 0, 0, 0.2);
      cursor: pointer;
      z-index: 10;
    }

    a.tooltip-close:hover {
      background: #ccc !important;
    }


    /* ğŸ”µ CRS + Scale å…±ç”¨å®¹å™¨æ¨£å¼ */
    #coord-scale-wrapper {
      position: absolute;
      bottom: 5px;
      left: 5px;
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(240, 248, 255, 0.95); /* æ·ºè—åŠé€æ˜èƒŒæ™¯ */
      border: 1px solid #bbb;
      padding: 4px 10px;
      border-radius: 4px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      color: #111;
      z-index: 1001;
    }
    
    .crs-selector select {
      margin-right: 4px;
      font-weight: bold;
      color: #0000cc;
      border: none;
      background: transparent;
      text-decoration: underline;
      cursor: pointer;
    }
    
    .crs-selector span {
      font-weight: bold;
      color: #222;
    }
    
    /* è®“ Leaflet scale æ§åˆ¶ä¸å¹²æ“¾å®šä½ */
    .leaflet-control-scale {
      position: static !important;
      margin-left: 8px;
    }
    
    /*  çµ±ä¸€ input è¼¸å…¥æ¡†æ¨£å¼ */
     #gotoPanel input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
    }
    /*   èª¿æ•´ radio çš„å¤–è§€é å·¦ + å°é½Š */
      #gotoPanel label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-weight: normal;
    } 
    .goto-row {
      display: grid;
      grid-template-columns: 20px 80px 120px;
      align-items: center;
      gap: 8px;
    }
    
    #clearBtn {
      background: #f8bfc4;
    }
    
    #clearBtn:hover {
      background-color: #d9534f;
      color: white;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.25);
      cursor: pointer;
    }
    
    #goBtn {
      background: #3d7728;
      color: white;
    }
    
    #goBtn:hover {
      background-color: #1e4f1b;
      color: white;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      cursor: pointer;
    }
    
    .info.legend {
      background: rgba(255,255,255,0.95);
      padding: 8px 12px;
      font: 13px Arial, sans-serif;
      color: #333;
      line-height: 1.4;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>

  <div id="map" style="position: relative;">
    <div id="coord-scale-wrapper">
      <div class="crs-selector">
        <select id="crsMode">
          <option value="hk1980">HK1980</option>
          <option value="wgs84">WGS84</option>
        </select>
        <span id="mouseCoords">X: â€“, Y: â€“</span>
      </div>
    </div>
    <div id="gotoToggleBtn" title="Go To Point" style="position: absolute; top: 120px; left: 10px; background: white; border: 1px solid #ccc; width: 32px; height: 32px; border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.3); cursor: pointer; z-index: 1001; display: flex; align-items: center; justify-content: center;">
      <i data-lucide="crosshair"></i>
    </div>
  </div>

  <!-- Go To Point åŠŸèƒ½ -->
    <div id="gotoPanel" style="
    display: none;
    position: absolute;
    top: 124px; left: 56px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 15px 15px;
    font-family: 'Arial', sans-serif;
    font-size: 14px;
    width: 250px;
    z-index: 1100;
    ">

    <h4 style="margin-top: 0;">Go To Point</h4>
    
    <div class="goto-row">
      <input type="radio" name="coordMode" value="hk1980" id="modeHK" />
      <label for="modeHK">Easting (X):</label>
      <input id="inputX" type="number" placeholder="e.g. 828988" />
    </div>
    
    <div class="goto-row">
      <span></span>
      <label>Northing (Y):</label>
      <input id="inputY" type="number" placeholder="e.g. 824199" />
    </div>
    
        
    <div class="goto-row">
      <input type="radio" name="coordMode" value="wgs84" id="modeWGS" />
      <label for="modeWGS">Latitude:</label>
      <input id="inputLat" type="number" placeholder="e.g. 22.356" />
    </div>
    
    <div class="goto-row">
      <span></span>
      <label>Longitude:</label>
      <input id="inputLng" type="number" placeholder="e.g. 114.101" />
    </div>

    <button id="clearBtn"
      style="border: none; padding: 6px 12px; border-radius: 6px; margin-right: 8px;">
      Clear All Point
    </button>
    
    <button id="goBtn"
      style="color: white; border: none; padding: 6px 20px; border-radius: 6px;">
      Go
    </button>

  </div>

  <!-- Hover Tooltip -->
  <div id="hoverTooltip" style="
    display: none;
    position: absolute;
    background: rgba(255,255,255,0.95);
    color: #000;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px 10px;
    font-size: 13px;
    font-family: Arial, sans-serif;
    line-height: 1.4;
    pointer-events: none;
    z-index: 999;
  "></div>

  <p id="last-modified" style="text-align:center; font-size:12px; color:gray; margin-top:30px;"></p>

  <!-- Proj4 è½‰æ›å·¥å…· -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>

  <script>
    const map = L.map('map', {
      gestureHandling: true,
      scrollWheelZoom: false
    });

    const hongKongBounds = [
      [22.1500, 113.8250],
      [22.5500, 114.4000]
    ];
    map.fitBounds(hongKongBounds);

    const scaleControl = L.control.scale({ imperial: false });
    scaleControl.addTo(map);
    
    // ç­‰å¾… Leaflet è¼‰å…¥å¾Œå°‡æ¯”ä¾‹å°º DOM æ’å…¥ wrapper
    map.whenReady(() => {
      const scaleEl = document.querySelector('.leaflet-control-scale');
      const wrapper = document.getElementById('coord-scale-wrapper');
      if (scaleEl && wrapper) {
        wrapper.appendChild(scaleEl);
      }
      lucide.createIcons();  // âœ… åˆå§‹åŒ– Lucide Icons
    });

    const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(map);
    const esriSatellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Tiles Â© Esri' });
    const googleStreets = L.tileLayer('https://mt1.google.com/vt/lyrs=m&x={x}&y={y}&z={z}', { attribution: 'Map data Â©2024 Google' });
    const googleSatellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', { attribution: 'Imagery Â©2024 Google' });
    const googleHybrid = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', { attribution: 'Imagery Â©2024 Google' });
    const baseMaps = {
      "è¡—é“åœ°åœ– (OSM)": streets,
      "è¡›æ˜Ÿåœ– (Esri)": esriSatellite,
      "Google è¡—é“åœ–": googleStreets,
      "Google è¡›æ˜Ÿåœ–": googleSatellite,
      "Google æ··åˆåœ–": googleHybrid
    };
    const isSmallDevice = window.matchMedia('(max-width: 1023px)').matches;
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const layersControl = L.control.layers(baseMaps, {}, { collapsed: true }).addTo(map);
    const gotoMarkers = [];  // å„²å­˜ Go To Point å»ºç«‹çš„ marker

    const legend = L.control({ position: 'bottomright' });  // All Bat Gridçš„Legend
    legend.onAdd = function () {
      const div = L.DomUtil.create('div', 'info legend');
      const grades = [1, 6, 11, 16, 21];
      const labels = [];
      const colors = ["#fde0dd", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"];
    
      div.innerHTML = '<strong>No. of Species</strong><br>';
    
      for (let i = 0; i < grades.length; i++) {
        const from = grades[i];
        const to = grades[i + 1] - 1;
        const rangeLabel = to ? `${from}â€“${to}` : `> ${from - 1}`;
        div.innerHTML += `
          <i style="background:${colors[i]}; width: 14px; height: 14px; display: inline-block; margin-right: 6px; border-radius: 2px;"></i>
          ${rangeLabel}<br>
        `;
      }
      return div;
    };

     map.on('overlayadd', function (e) {
      if (e.name === "All Bat Distribution (Grid)") {
        legend.addTo(map);
      }
    });
    
    map.on('overlayremove', function (e) {
      if (e.name === "All Bat Distribution (Grid)") {
        map.removeControl(legend);
      }
    });
    
    let gridLayer = L.geoJSON(null, { style: { color: '#666', weight: 1, fillColor: '#41b6c4', fillOpacity: 0.3 } });
    let lockedLayers = [];
    let tooltipElements = [];
    let manualMoved = [];
    let maxLockedTooltips = 3;

    function positionTooltipToSameOffset(domElement, latlng) {
      const point = map.latLngToContainerPoint(latlng);
      const mapRect = map.getContainer().getBoundingClientRect();
      const left = mapRect.left + point.x + 15;
      const top = mapRect.top + point.y + 15;

      domElement.style.position = 'absolute';
      domElement.style.left = `${left}px`;
      domElement.style.top = `${top}px`;
    }

      function adjustTooltipPosition(tooltip, point) {
        if (getComputedStyle(tooltip).position !== 'absolute') {
          tooltip.style.position = 'absolute';
        }
      
        const mapSize = map.getSize();
        let left = point.x + 15;
        let top = point.y + 15;
      
        if (left + tooltip.offsetWidth > mapSize.x) left = point.x - tooltip.offsetWidth - 15;
        if (top + tooltip.offsetHeight > mapSize.y) top = point.y - tooltip.offsetHeight - 15;
        if (left < 0) left = 10;
        if (top < 0) top = 10;
      
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
      }

    function updateAllLockedTooltips() {
      lockedLayers.forEach((layer, index) => {
        if (manualMoved[index]) return;
        const tooltip = tooltipElements[index];
        const center = map.latLngToContainerPoint(layer.getBounds().getCenter());
        adjustTooltipPosition(tooltip, center);
      });
    }

    function makeTooltipDraggable(tooltip, index) {
      let isDragging = false;
      let offsetX, offsetY;

      tooltip.addEventListener('mousedown', function(e) {
        isDragging = true;
        offsetX = e.clientX - tooltip.offsetLeft;
        offsetY = e.clientY - tooltip.offsetTop;
        tooltip.style.cursor = 'move';
        tooltip.style.opacity = '0.7';
        e.stopPropagation();
      });

      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          tooltip.style.left = (e.clientX - offsetX) + 'px';
          tooltip.style.top = (e.clientY - offsetY) + 'px';
        }
      });

      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          tooltip.style.cursor = 'default';
          tooltip.style.transition = 'opacity 0.2s ease';
          tooltip.style.opacity = '1';
          manualMoved[index] = true;
          setTimeout(() => { tooltip.style.transition = ''; }, 200);
        }
      });
    }

    function openLockTooltip(layer) {
      const tooltip = document.createElement('div');
      tooltip.className = 'floatingTooltip';
      tooltip.setAttribute('data-layer-id', L.stamp(layer));
      tooltip.innerHTML = `
        <div class="tooltip-container">
          <a href="#" class="tooltip-close" onclick="closeLockTooltip(event, this);">âœ–</a>
          <div class="tooltip-content">
            ${layer.options.tooltipContent}
          </div>
        </div>
      `;
      document.getElementById('map').appendChild(tooltip);

      lockedLayers.push(layer);
      tooltipElements.push(tooltip);
      manualMoved.push(false);

      const centerPoint = map.latLngToContainerPoint(layer.getBounds().getCenter());
      setTimeout(() => {
        adjustTooltipPosition(tooltip, centerPoint);
      }, 30); // å»¶å¾Œä¸€é»é»ç¢ºä¿ DOM å¯¦éš›ç¹ªè£½å®Œæˆ
     
      makeTooltipDraggable(tooltip, lockedLayers.length - 1);
    }

    function closeLockTooltip(event, closeButton) {
      event.preventDefault();
      const tooltip = closeButton.closest('.floatingTooltip');
      const layerId = parseInt(tooltip.dataset.layerId);
      const idx = lockedLayers.findIndex(l => L.stamp(l) === layerId);

      if (idx !== -1) {
        const layer = lockedLayers[idx];
      const gridNo = layer.feature.properties.Grid_No;
      const count = speciesData[gridNo] ? speciesData[gridNo].count : 0;
      layer.setStyle(getGridStyle(count));
        lockedLayers.splice(idx, 1);
        tooltipElements[idx].remove();
        tooltipElements.splice(idx, 1);
        manualMoved.splice(idx, 1);
      }
    }

    const hoverTooltip = document.getElementById('hoverTooltip');
    
    function getGridStyle(count) {
      let fillColor = "#fff";
      let fillOpacity = 0;
    
      if (count === 0 || count === "0" || count === "" || count === null) {
        fillOpacity = 0;
      } else {
        count = Number(count);
        fillOpacity = 0.75;
      if (count >= 1 && count <= 5) fillColor = "#fde0dd";    // very light pink
      else if (count <= 10)          fillColor = "#fbb4b9";    // light pink
      else if (count <= 15)          fillColor = "#f768a1";    // medium pink-red
      else if (count <= 20)          fillColor = "#c51b8a";    // strong magenta-red
      else                           fillColor = "#7a0177";    // dark purple-red
      }
    
      return {
        color: "#666",
        weight: 1,
        fillColor,
        fillOpacity
      };
    }
    
    function setupGridLayerFeature(feature, layer) {
      const gridNo = feature.properties.Grid_No;
      if (speciesData[gridNo]) {
        const info = speciesData[gridNo];
        let content = "";

        if (!info.list || info.list.trim() === "" || info.list === "N/A") {
          content = `<strong>ç·¨è™Ÿ:</strong> ${gridNo}<br>æš«ç„¡ç‰©ç¨®è¨˜éŒ„`;
        } else {
          const speciesArray = info.list.split(', ').sort();
          const speciesListHtml = speciesArray.map((s, i) => `${i + 1}. <i>${s}</i>`).join('<br>');
          content = `<strong>ç·¨è™Ÿ:</strong> ${gridNo}<br><strong>æ•¸é‡:</strong> ${info.count} ç¨®<br><strong>æ¸…å–®:</strong><br>${speciesListHtml}`;
        }

        layer.options.tooltipContent = content;

        if (!isTouchDevice) {
          layer.on('mouseover', function() {
            if (!lockedLayers.includes(this)) {
              hoverTooltip.innerHTML = this.options.tooltipContent;
              hoverTooltip.style.display = 'block';
            }
          });

          layer.on('mousemove', function(e) {
            if (!lockedLayers.includes(this)) {
              const point = map.latLngToContainerPoint(e.latlng);
              adjustTooltipPosition(hoverTooltip, point);
            }
          });

          layer.on('mouseout', function() {
            hoverTooltip.style.display = 'none';
          });
        }

        layer.on('click', function() {
          if (lockedLayers.includes(this)) {
            const idx = lockedLayers.indexOf(this);
            lockedLayers.splice(idx, 1);
            tooltipElements[idx].remove();
            tooltipElements.splice(idx, 1);
            manualMoved.splice(idx, 1);
            this.setStyle(getGridStyle(info.count));
          } else {
            if (lockedLayers.length >= maxLockedTooltips) {
              alert('æœ€å¤šåªèƒ½é–å®š ' + maxLockedTooltips + ' å€‹Tooltip');
              return;
            }
            this.setStyle({ color: '#333', weight: 2, fillColor: '#ffcc00', fillOpacity: 0.7 });
            openLockTooltip(this);
          }
        });
      }
    }

    map.on('move zoom', () => {
      updateAllLockedTooltips();
    });

    let speciesData = {};

    fetch('https://opensheet.elk.sh/1Al_sWwiIU6DtQv6sMFvXb9wBUbBiE-zcYk8vEwV82x8/sheet1')
      .then(r => r.json())
      .then(data => {
        data.forEach(item => {
          speciesData[item["Grid No."]] = {
            list: item["Species List"],
            count: item["No. of Species"]
          };
        });
        fetch('https://raw.githubusercontent.com/PanTong55/hkgrid/main/hkgrid.geojson')
          .then(r => r.json())
          .then(gridData => {
            gridLayer.options.onEachFeature = setupGridLayerFeature;
            gridLayer = L.geoJSON(gridData, {
              style: function(feature) {
                const gridNo = feature.properties.Grid_No;
                const info = speciesData[gridNo];
                const count = info ? info.count : 0;
                return getGridStyle(count);
              },
              onEachFeature: setupGridLayerFeature
            });
            layersControl.addOverlay(gridLayer, "All Bat Distribution (Grid)");
          });
      });

    const crsModeSelect = document.getElementById('crsMode');
    const coordDisplay = document.getElementById('mouseCoords');

    map.on('mousemove', function (e) {
      const mode = crsModeSelect.value;
      if (mode === 'wgs84') {
        coordDisplay.textContent = `Lon: ${e.latlng.lng.toFixed(6)}  Lat: ${e.latlng.lat.toFixed(6)}`;
      } else {
        const hk1980 = proj4(
          '+proj=tmerc +lat_0=22.31213333333333 +lon_0=114.1785555555556 +k=1 +x_0=836694.05 +y_0=819069.8 +ellps=intl +units=m +no_defs',
          [e.latlng.lng, e.latlng.lat]
        );
        coordDisplay.textContent = `X: ${Math.round(hk1980[0])}  Y: ${Math.round(hk1980[1])}`;
      }
    });
    
    // åŠ  Go To Point
    document.getElementById('gotoToggleBtn').addEventListener('click', () => {
      const panel = document.getElementById('gotoPanel');
      const btn = document.getElementById('gotoToggleBtn');
      
      const isOpen = panel.style.display === 'block';
      
      if (isOpen) {
        panel.style.display = 'none';
        btn.innerHTML = '<i data-lucide="crosshair"></i>';
        lucide.createIcons(); // â† é¡¯ç¤ºåœ–ç¤º
      } else {
        panel.style.display = 'block';
        btn.innerHTML = '<i data-lucide="chevrons-left"></i>';
        lucide.createIcons(); // â† é¡¯ç¤ºè¿”å›ç®­é ­
      }
    });

    document.getElementById('goBtn').addEventListener('click', () => {
      const mode = document.querySelector('input[name="coordMode"]:checked').value;
    
      let latlng = null;
    
      if (mode === 'hk1980') {
        const x = parseFloat(document.getElementById('inputX').value);
        const y = parseFloat(document.getElementById('inputY').value);
        if (!isNaN(x) && !isNaN(y)) {
          const result = proj4(
            '+proj=tmerc +lat_0=22.31213333333333 +lon_0=114.1785555555556 +k=1 +x_0=836694.05 +y_0=819069.8 +ellps=intl +units=m +no_defs',
            'WGS84',
            [x, y]
          );
          latlng = { lat: result[1], lng: result[0] };
        }
      } else {
        const lat = parseFloat(document.getElementById('inputLat').value);
        const lng = parseFloat(document.getElementById('inputLng').value);
        if (!isNaN(lat) && !isNaN(lng)) {
          latlng = { lat, lng };
        }
      }
    
    if (latlng) {
      map.setView(latlng, 16);
      const marker = L.marker(latlng).addTo(map);
      gotoMarkers.push(marker); // âœ… åŠ å…¥ marker é™£åˆ—ä¸­
    }
    });
    
    document.getElementById('clearBtn').addEventListener('click', () => {
      gotoMarkers.forEach(m => map.removeLayer(m)); // âœ… å¾åœ°åœ–ç§»é™¤æ‰€æœ‰ marker
      gotoMarkers.length = 0; // âœ… æ¸…ç©ºé™£åˆ—
    });
    
    const lastModified = new Date(document.lastModified);
    const formatted = lastModified.toLocaleString('zh-Hant', {
      year: 'numeric', month: '2-digit', day: '2-digit',
      hour: '2-digit', minute: '2-digit'
    });
    document.getElementById("last-modified").textContent = "æ­¤é æœ€å¾Œä¿®æ”¹æ™‚é–“ï¼š" + formatted;
  </script>

</body>
</html>
